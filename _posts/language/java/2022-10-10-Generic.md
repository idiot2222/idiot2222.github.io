---
title: Generic
date: 2022-10-10 19:30:00 +0900
categories: [Language, Java]
tags: [java, generic]
---


<br/>
<br/>
<br/>
<br/>

### 참고

- [java in a nutshell](https://www.oreilly.com/library/view/java-in-a/9781492037248/)

<br/>
<br/>


# Generic의 탄생 배경

- 자바의 Collections는 아주 유용한 라이브러리이다.
- 그러나 초기의 Collections는 상당히 큰 제한이 있었다.
  - 컬렉션 내의 데이터들의 타입을 모호하게 한다는 점이었다.
  - 데이터 은닉과 캡슐화는 객체 지향의 훌륭한 원칙이지만,
  - 이런 경우에는 오히려 많은 문제를 야기할 수 있었다.

<br/>
<br/>

```java
List animals = new ArrayList();

animals.add(new Dog());
animals.add(new Cat());

// 리턴 타입은 Object이다. 따라서 타입 캐스팅을 해줘야 한다.
Object o = animals.get(0);

Dog dog = (Dog) animals.get(0);
Dog cat = (Dog) animals.get(1); // 런타임 에러 발생
```

- 이 코드는 컴파일 시점에는 아무 문제가 없다. 하지만 결국엔 프로그램이 터져버렸다.
- animals 리스트는 자신이 갖고 있는 객체의 타입을 알지 못한다.
  - 이 리스트는 서로 다른 타입의 객체를 넣을 수 있다.
  - 만약 리스트가 자신이 어떤 타입의 객체들을 갖고 있어야 하는지 알고 있다면,
    - 컴파일 시점에 위의 에러를 잡을 수 있었을 것이다.

<br/>
<br/>

```java
List<Dog> dogs = new ArrayList(); // 리스트가 어떤 타입의 객체를 갖는지 명시해준다.

dogs.add(new Dog());
dogs.add(new Cat()); // 컴파일 에러 발생

Dog dog = dogs.get(0);
```

- 이 코드는 리스트가 Dog 타입을 가져야한다고 명시해줬다.
  - <> 이걸 사용해서
- Cat 타입의 객체를 리스트에 넣으려고하자 컴파일 에러로 사전에 잡아낼 수 있었다.
- 별도의 타입 캐스팅 없이 Dog 리스트에서 Dog 객체를 꺼낼 수 있게 되었다.

<br/>

- 이렇게 객체를 둘러싸는 컨테이너의 타입과
  - 안에 들어가는 객체의 타입을
  - 결합한 타입을 제네릭 타입이라고 한다.
- 아래와 같이 선언할 수 있다.

```java
interface MyList<T> extends Collection<T> {
    void add(T element);
    T get();
}
```

- MyList는 모든 타입의 객체를 보유할 수 있는 구조로 선언된 것이다.
  - T는 타입 파라미터로,
    - String이 될 수도, Integer가 될 수도 혹은 유저 정의 클래스가 들어올 수도 있다.
  - T가 어느 타입인지 결정되면,
    - 아래 메서드 add와 get의 파라미터 타입, 리턴 타입이 결정되는 것이다.

<br/>
<br/>

## Generic의 타입 파라미터

- 위 예시 코드에서 봤던 <T>를 타입 파라미터라고 한다.
- 타입 파라미터를 가지는 타입을 선언할 때,
  - 추정하는 형태로 선언해서는 안된다.
  - List< E > dogs = new ArraysList<>(); - X
  - List< String > dogs = new ArraysList<>(); - O
  - 이렇게 구체적인 값을 할당해야 한다.
  - 타입 파라미터는 참조형 타입이어야 한다. 원시형 타입은 올 수가 없다.
- 타입 파라미터는 실제 타입처럼 메서드 시그니처와 본문에서 사용할 수 있다.
  - 위의 MyList 예시를 보면,
    - 타입 파라미터인 T를 리턴값으로 잡기도 하고,
    - 파라미터의 타입으로 받기도 한다.

<br/>
<br/>

## 다이아몬드 문법

- 제네릭 타입을 갖는 객체를 선언할 때
  - new 연산자로 인스턴스를 생성하는 오른쪽 구문에는
  - 타입 파라미터를 또 적을 필요가 없다.
  - 이것을 타입 유추라고 한다.
- 타입을 명시하는 왼쪽 구문에서 명확한 제네릭 타입을 정의했다면,
  - 컴파일러가 인스턴스의 타입을 유추할 수 있기 때문에
  - 오른쪽 구문에서 또 써줄 필요가 없다.

```java
// 이렇게 써줘도 된다.
MyList<String> strings = new MyList<String>();

// 그러나 이렇게 생략해도 된다.
MyList<Integer> integers = new MyList<>();
```

<br/>
<br/>

## 타입 삭제

- jdk 5부터 Generic이 생겼고,
  - 이 때문에 이전의 non-generic 컬렉션들과의 호환이 문제였다.
  - non-generic 컬렉션들은 row 타입 컬렉션이라고도 한다.
    - 현재도 컴파일 에러가 없는 합법적인 자바 코드이다.
    - 물론 좋지 못한 코드이다.
- 문제의 핵심은 기존의 non-generic 컬렉션들과 새로운 제네릭 컬렉션들을 함께 사용할 수 있는 방법을 찾는 것이었다.
  - 이 설계에 대한 문제 해결 방법으로 사용한게 타입 캐스팅이었다.

```java
// 기존의 non-generic 컬렉션
List oldList = new ArrayList();

// 타입 캐스팅으로 변환
List<String> newList = (List<String>) oldList;
```

- 이 예시에서 List를 List<String>으로 타입 캐스팅했다는 것은
  - 두 타입이 어느 정도 호환된다는 것을 의미한다.
  - 자바는 타입 삭제를 이용해 이런 호환성을 달성할 수 있었다.
- 웬 타입 삭제?
  - 제네릭 타입 파라미터는 컴파일 시점까지만 볼 수 있으며,
  - 컴파일러에 의해 삭제되고
  - 런타임 시점 즉, 바이트코드에는 반영되지 않는다.

```java
interface MyInterface {

    void printList(List<Integer> integerList);

    void printList(List<String> stringList);

}
```

- 위의 예시는 얼핏 보면 그냥 오버로드로 보인다.
  - 그러나 컴파일 에러가 발생한다.
- 두 printList 메서드가 받는 파라미터는 컴파일 시점에 타입 파라미터가 삭제된다.
  - 결국엔 두 메소드 모두 파라미터로 raw type인 List를 받는 것으로
  - 완전 똑같은 모양이 되어버린다.

<br/>
<br/>
<br/>
<br/>
