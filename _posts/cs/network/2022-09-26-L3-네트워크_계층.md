---
title: L3 네트워크 계층
date: 2022-09-26 00:50:00 +0900
categories: [CS, Network]
tags: [cs, network, l3, network_layer]
---



<br/>
<br/>
<br/>
<br/>

# 네트워크 계층

- 네트워크와 네트워크 간의 통신을 담당하는 계층이다.
  - 가까운 곳이 아닌 더 먼 곳에 있는 노드와의 통신이 가능하게 해준다.
  - LAN에서 다른 LAN으로의 통신.
- 물리적 주소가 아닌 논리적 주소인 IP를 이용한다.
- 주요 프로토콜로는 IP, ARP, ICMP, NAT 등이 있다.
- 주요 기기로는 라우터가 있다.
- 3계층의 PDU는 패킷이다.

<br/>
<br/>


## IP

- Internet Protocol
- 비신뢰성
  - 데이터 수신을 보장하지 않는다.
- 비연결성
  - 데이터를 보낼 때 사전 호출이나, 연결 설정 행위를 따로 하지 않는다.
- ip 주소
  - 컴퓨터의 논리적 주소를 나타낸다.
- 라우팅
  - ip 주소를 통해 목적지까지의 경로 설정을 한다.

> - 네트워크 상에서 데이터를 전송하기 위한 프로토콜.
> - 데이터가 정확하게 전달될 것을 보장하지는 않는다.
>   - 중복된 데이터를 또 보낼 수도 있고, 패킷의 순서가 뒤죽박죽일 수도 있다.
>   - 데이터의 정확하고 순차적인 전송은 L4의 TCP가 보장한다.

<br/>
<br/>
<br/>
<br/>

# IP Address

- 각 기기들을 구별하기 위한 논리적 주소이다.
- IPv4
  - 8비트씩 총 32비트, 10진수로 나타낸다. 약 43억개의 주소를 구분할 수 있다.
  - 0.0.0.0 ~ 255.255.255.255
- IPv6
  - 16비트씩 총 128비트, 16진수로 나타낸다. 나타낼 수 있는 수가 매우 크다.
  - 0000:0000:0000:0000:0000:0000:0000:0000 ~ ffff.ffff.ffff.ffff.ffff.ffff.ffff.ffff
- IP 주소는 기기에게도 주어지지만, 네트워크를 나타내는 주소도 주어진다. (라우터에게)

<br/>
<br/>

## Classful Addressing

- IP 주소를 규격화된 크기별(클래스)로 구분시키는 방식
- 클래스는 A, B, C, D, E로 나뉜다.

<br/>

![img-description](assets/img/posting/network/classful_ip.png)
_Classful IP address (너무 길어서 4비트씩만 적어놓음)_

- A 클래스
  - MSB가 0인 클래스
  - 가장 왼쪽부터 8비트가 네트워크 ID, 나머지 24비트가 호스트 ID
  - 0.0.0.0 ~ 127.255.255.255
  - 255개의 네트워크를 가질 수 있다.
  - 하나의 네트워크가 255 * 255 * 255개의 호스트를 가질 수 있다.
- B 클래스
  - MSB부터 2비트가 10으로 시작하는 클래스
  - 가장 왼쪽부터 16비트가 네트워크 ID, 나머지 16비트가 호스트 ID
  - 128.0.0.0 ~ 191.255.255.255
  - 255 * 255개의 네트워크를 가질 수 있다.
  - 하나의 네트워크가 255 * 255개의 호스트를 가질 수 있다.
- C 클래스
  - MSB부터 3비트가 110으로 시작하는 클래스
  - 가장 왼쪽부터 24비트가 네트워크 ID, 나머지 8비트가 호스트 ID
  - 192.0.0.0 ~ 223.255.255.255
  - 255 * 255 * 255개의 네트워크를 가질 수 있다.
  - 하나의 네트워크가 255개의 호스트를 가질 수 있다.
- D 클래스
  - MSB부터 4비트가 1110으로 시작하는 클래스
  - 224.0.0.0 ~ 239.255.255.255
  - 멀티캐스트용 주소
- E 클래스
  - MSB부터 4비트가 1111으로 시작하는 클래스
  - 240.0.0.0 ~ 255.255.255.255
  - 실험용, 장래 대비용 주소

> 각 네트워크의 첫 번째는 네트워크를 나타내는 주소,
> 마지막은 브로드캐스트 주소이다.
> > 192.168.60이라는 이 C 클래스 네트워크는 192.168.60.0이 네트워크 주소, 192.168.60.255가 브로드캐스트 주소이다.

<br/>
<br/>


## Classless Addressing

- 클래스풀한 주소 체계를 사용하면, 하나의 네트워크에 너무 많은 주소가 할당된다.
  - 만약 내가 50개 정도의 아이피 주소가 필요한데, A 클래스의 네트워크를 할당 받았다고 한다면.
  - 255 * 255 * 255 - 50개의 주소가 낭비가 된다.
- Classful Addressing이 클래스 형태로 네트워크를 구분하는 것과 반해서, 클래스의 구분 없이 비트 단위로 주소를 부여하는 방식이다.
- 클래스 별로 네트워크를 나누는 것이 아닌 비트에 따라 네트워크를 나누는 것이다.
  - 비트 단위로 쪼개기 위해 서브넷 마스크를 사용한다.

- 서브넷 마스크
  - 192.168.60.55라는 IP가 있다.
  - 같이 딸려온 서브넷 마스크는 255.255.255.0이다.
  - 얘의 네트워크 ID와 호스트 ID를 구분하고 싶다.
  - IP 주소와 서브넷 마스크에 and 연산을 때려준다. 192.168.60.0 얘가 네트워크 ID이다.
  - 서브넷 마스크는 왼쪽부터 연속된 1로 나타낸다. 1이 끝나면 나머지는 무조건 전부 0이다. 표기할 때는 1의 개수를 표기한다.
    - 255.255.255.0 => /24
    - 192.168.60.0 /24 => 왼쪽부터 24비트가 네트워크 ID를 나타낸다는 뜻.


<br/>
<br/>

## Subnetting

- 너무 큰 네트워크를 쪼개서 사용하는 것을 서브넷팅이라고 한다.
  - 분할된 네트워크를 서브넷이라고 한다.
  - 네트워크 ID와 호스트 ID를 구분하기 위한 값이 위에서의 서브넷 마스크이다.

- 서브넷팅
  - 네트워크를 쪼개서 네트워크 수는 늘리고, 호스트 수는 줄이는 방법이다.
  - 192.168.60.0 /24는 평범한 C 클래스 네트워크이다. 254개의 호스트를 가질 수 있다.
    - 그러나 254개는 너무 많아서 낭비이다. 절반으로 줄이기로 했다.
  - 192.168.60.0 /25로 서브넷 마스크를 한 비트 더 땡겼다. (255.255.255.128)
    - 네트워크가 2배로 늘어나고, 호스트는 절반으로 줄어들었다.
  - 그러나 여전히 많아서 한 비트 더 땡겼다. 192.168.60.0 /26 (255.255.255.192)
    - 네트워크가 2배 더 늘고, 호스트는 또 절반으로 줄어들었다.
  - 반대 개념을 수퍼넷팅이 있다.


<br/>
<br/>

## 그러나 아직도 부족한 IP

- 서브넷팅으로 최대한 쪼개서 사용해도 낭비가 아예 없을 순 없다.
- 거기에다가 최근 늘어난 it 기기들로 인해서 ip 주소가 매우 부족해졌다.
- 여기서 나온 논의가 IPv6로 다 넘어가자! 인데 현실적인 문제가 있다.
  - 현재 사용중인 대부분의 장비를 업그레이드 해줘야 한다. (IPv6를 모른다 걔네는)
- 그래서 나온 방법이 사설 IP * 공인 IP이다.


- 사설 IP는 같은 네트워크 대역에서 사용하는 IP이다.
- 공인 IP는 바깥으로 나가서 외부와 연결할 때 사용하는 IP이다.
- 같은 네트워크 대역에서 통신을 할 때는 사설 IP로 충분하다.
- 네이버나 구글 등의 다른 네트워크 대역과 통신하기 위해서는 사설 IP를 공인 IP로 변환하여 사용한다. (공인 -> 사설도 마찬가지)
  - NAT 프로토콜을 이용한다. (특정 ip를 다른 어떠한 ip로 바꾸는 기술)
  - 네이버에 내 ip 주소를 물어보면, 터미널에 물어본 거(ifconfig | grep inet)랑 다르게 나온다.
  - 네이버가 알려준 것이 외부에서 보이는 나의 공인 ip, 터미널이 알려준 것은 내 네트워크 대역 안의 사설 ip이다.
- 공인 IP 하나당 0.0.0.0 ~ 255.255.255.255 범위의 사설 IP가 있는 꼴이다.


외부의 노드와 통신할 때는
- 외부의 노드는 송신자 아이피로 공인 아이피를 받는다.
- 외부의 노드는 응답을 준비하여 내 공인 아이피를 수신자로 지정하여 보낸다.
- 내 공인 아이피의 도착지인 내가 속한 네트워크의 라우터가 받는다.
- 공유기가 누가 요청했는지 파악하여 사설 아이피를 통해 내 컴퓨터로 보낸다.
  - 내부의 요청이 외부 대역으로 나갈 때, 기록을 해뒀다가 들어올 때 누가 보냈던 건지 기억하는 것이다. (NAT Table)
  - 만약 NAT 테이블에 기록되지 않은(사설 대역에서 외부로 나가지 않은) 데이터가 공인 아이피를 타고 들어온다면?
    - 공유기가 받고 끝이다. 어디로 다시 보내지 않는다.
    - 반대로 우리가 구글이나 네이버에 요청을 보낼 때 공인 ip 주소로 보내면, 어떻게 사설 ip로 변환하여 받을 수 있을까?
      - 결론부터 말하면 받을 수 없다.
      - 그래서 서비스의 서버들은 사설 아이피를 잘 사용하지 않는다.
      - 혹은 port forwarding을 사용한다.




<br/>
<br/>

## 특수한 IP 주소들

- 0.0.0.0
  - Wildcard
  - 나머지 모든 IP를 가르킨다.
- 127.0.0.1
  - 자기 자신을 가르킨다.
- 게이트웨이
  - 내 네트워크 대역에서 외부로 통신하기 위해서 나가는 문이다.
  - 내 네트워크 대역에서 가장 작은 아이피나 가장 큰 아이피를 주는게 일반적이다.
    - 192.168.60.0 /24 일 때, 192.168.60.1을 주거나 255를 준다.
  - 인터넷을 사용하기 위해선 게이트웨이를 필수적으로 알아야 한다.



<br/>
<br/>
<br/>
<br/>


# 패킷


<br/>

![img-description](assets/img/posting/network/ip_packet.png)
_ip 패킷_

<br/>

- l3의 pdu이다.
- 최소 20바이트에서 최대 60바이트 길이의 헤더가 붙는다.
- 원래 하나의 데이터를 잘게 쪼개서 각각 헤더를 붙여 패킷으로 만든다.
  - 받는 쪽에서 패킷을 모아 다시 합쳐서 사용한다.

<br/>
<br/>

## 패킷 조각화





<br/>
<br/>
<br/>
<br/>


# IPv4 프로토콜

<br/>

![img-description](assets/img/posting/network/IPv4.png)
_ipv4 프로토콜_

<br/>

- Version
  - ip 프로토콜의 버전을 나타내는 값.
  - 이거는 IPv4이기 때문에, 4가 온다.
  - IPv6은 모양이 다르기 때문에 무조건 4가 온다고 생각하면 된다.
- Header Length
  - IPv4 헤더의 길이를 나타내는 값이다.
  - 4비트
    - 0~15를 나타낼 수 있는 4비트는
    - 20~60바이트 범위의 크기를 갖는 헤더를 나타내기에는 너무 작은 수다.
    - 그래서 4로 나눈 값을 넣는다. 5~15
- Type of Service
  - 현재 보내는 데이터의 형식을 나타내는 값이다. (패킷의 우선 순위)
  - 현재는 쓰이지 않는다고 한다.
- Total Length
  - 헤더를 포함한 페이로드까지 전체의 길이를 나타내는 값이다.

<br/>

- Identification
  - 패킷은 하나의 데이터를 잘게 쪼개서 각각 헤더를 붙여 보낸다.
  - 수신자는 잘게 쪼개진 패킷을 모아서 하나로 합쳐서 사용한다.
  - 그때 잘게 쪼개진 패킷을 식별하기 위한 값이다.
  - 수신자는 이 값이 같은 애들끼리 모아 붙여서 사용한다.
- flag
  - 단편화 플래그이다.
  - 데이터를 단편화 했는지 안했는지 등의 단편화 관련 정보를 나타낸다.
  - 단편화 여부 등의 옵션이 있는데
    - 단편화 하지 않으면 데이터를 보낼 수가 없기 때문에 거의 쓰이지 않는 부분이라고 한다.
    - 물론 엄청 작은 값은 단편화 하지 않아도 되니까 얘를 쓴다.
  - 단편화가 됐다고 했을 때, 뒤에 패킷이 더 있는지를 나타내는 MF (More Fragment)가 있다.
    - 패킷이 5개로 쪼개졌다고 했을 때
    - 1번부터 4번까지의 패킷들은 MF의 값이 1이다. (내 뒤에 패킷이 더 있다는 뜻)
    - 마지막 패킷은 MF가 0이다.
- Fragment Offset
  - 단편화 된 조각의 순서를 말한다.
  - 수신자가 나중에 이 숫자를 보고 순서대로 조립한다.
  - 순서대로 1,2,3 이렇게 붙여주는게 아니라, 받았을 때 바로 합칠 수 있도록 오프셋을 준다.
    - 예를 들어서, 5000byte 패킷을 2000byte씩 쪼갰다고 한다.
    - 1: 2000, 2: 2000, 3: 1000 이렇게 나눠진다.
    - 1번 패킷의 offset은 0이다.
    - 2번 패킷의 offset은 2000이다.
    - 3번 패킷의 offset은 4000이다.
    - 근데 이렇게 나누면 숫자가 너무 크기 때문에 8로 나눈 값을 넣는다.
    - 1: 0, 2: 250, 3: 500 이렇게

<br/>

- Time To Live
  - 패킷이 살아있는 시간을 의미한다.
  - 송신자가 패킷을 보낼 때 10의 ttl을 설정하고 보냈다고 한다. (여기서 10은 수신지까지 가기에 충분한 값이다.)
    - 목적지로 가기 위해서, 라우터 같은 L3 장비를 하나씩 거치게 된다. 그때, ttl 값을 하나씩 줄인다.
  - 만약 L3 장비들 사이에서 무언가 잘못되어 패킷이 어느 한 지점에서 순환한다면,
    - 네트워크가 혼란스러워진다. (디도스 공격이나 마찬가지)
    - ttl은 그것을 방지하기 위함이다.
    - 재전송 등의 신뢰성을 보장하는 행위는 L4에서 한다.
- Protocol Type
  - 상위 프로토콜의 타입을 나타내는 값.
  - ICMP, TCP, UDP 등
- Header Checksum
  - 헤더의 에러 유무를 확인하는 값.
  - 헤더의 값들로 특정한 계산을 해서 넣은 값이다.
  - 보낼 때의 값과 받을 때 다시 계산한 값을 비교하여 패킷에 오류가 없는지 확인할 수 있다.

<br/>

- Source Address
  - 송신자의 ip 주소
- Destination Address
  - 수신자의 ip 주소
- Optional
  - 부가적으로 붙은 옵션이다.
  - 하나의 4바이트이며, 최대 10개가 붙을 수 있다.



<br/>
<br/>
<br/>
<br/>

# 라우터

- 네트워크에서 다른 네트워크로 데이터를 전송하는 장비이다.
- 공인 ip와 사설 ip를 갖는다.
  - 네트워크의 출입구가 되어준다.
  - 라우터가 여러 네트워크와 연결된 상태라면, 네트워크 대역마다 다른 사설 ip를 가진다.

<br/>

- 라우팅 테이블
  - 목적지 주소를 가기 위해선 어느 경로로 가야하는지를 기록해둔 테이블이다.
    - 192.168.0.10 컴퓨터는 192.168.10.24 컴퓨터와 통신하고 싶다.
    - 192.168.0.10 컴퓨터는 192.168.10.0/24 네트워크 대역으로 가기 위해선 어디로 가야하는지 알고 있다.
      - 192.168.10.0/24 -> 192.168.0.1 (게이트 웨이)
      - 이런식으로 기록해둔다.

<br/>
<br/>

## 라우팅 과정

<br/>

![img-description](assets/img/posting/network/routing.png)
_라우팅 과정_

<br/>

1. A 컴퓨터에서 다른 네트워크 대역에 있는 B 컴퓨터로 통신을 하려고 한다.
   - A 컴퓨터는 B 컴퓨터의 아이피 주소를 알고 있다.
     - => ip 헤더의 목적지 ip 주소에 적는다.
   - A의 라우팅 테이블은 게이트 웨이의 ip 주소를 알고 있다.
     - => ARP 요청을 보내서 게이트 웨이의 mac 주소를 알아낸다.
     - => 이더넷 헤더의 목적지 mac 주소에 적는다.
2. 외부로 연결되어 있는 a 라우터에게 전달할 메시지를 보낸다.(게이트 웨이)
   - a 라우터의 라우팅 테이블은 B가 속한 네트워크 대역으로 가는 경로를 알고 있다. (b 라우터)
   - b 라우터로 가기 위해서 이더넷 헤더를 새로 작성해서 붙인다.
     - => 라우팅 테이블에 적힌 b 라우터의 ip 주소를 사용한다.
     - => 역시 ARP 로 b 라우터의 mac 주소를 알아낸다.
3. b 라우터 역시 B 컴퓨터로 가기 위해 c 라우터에게 보낸다.
   - 라우팅 테이블을 참조한다.
   - 또 이더넷 헤더를 교체한다.
4. c 라우터는 B 컴퓨터로 보낸다.
   - 라우팅 테이블을 참조한다.
   - 역시 이더넷 헤더를 교체한다.
5. 응답은 역순으로 진행한다.

<br/>

> 라우터는 여러 네트워크에 연결되어 있다.
> 각각의 네트워크는 라우터에 다른 사설 ip를 부여한다.
> 인터넷과 연결된 라우터는 공인 ip를 갖고 있다.

<br/>
<br/>
<br/>
<br/>

# ARP

- 통신을 할 때는 보통 IP 주소만을 입력해서 상대방과 통신한다.
- 그러나 같은 네트워크 대역에서 수신지를 찾아가기 위해서는 IP 주소가 아닌, MAC 주소가 필요하다.
- 그때 사용하는 것이 ARP이다. IP 주소를 통해 MAC 주소를 찾아낸다.
- 보안상에서도 중요한 역할을 한다. (ARP Spoofing)

<br/>

- 근데 의문점이 드는게 같은 대역의 네트워크에서 사용하는 프로토콜인데, 왜 L3 프로토콜이라고 분류할까?
  - ip 주소가 필요해서 그렇다고 한다..



<br/>

![img-description](assets/img/posting/network/ARP-01.png)
_ARP 프로토콜_

<br/>

- Hardware Type
  - L2에서 사용할 프로토콜을 나타내는 값
  - 2byte
  - 내가 아는건 이더넷 프로토콜 뿐이다. 16진수로 0001
- Protocol Type
  - Protocol Address의 타입을 나타내는 값
  - 2byte
  - IPv4를 사용하면, 16진수로 0800
- Opcode
  - 수신인지 송신인지의 여부
  - ARP 프로토콜로 내가 MAC 주소를 물어보고 있는지? = 1
  - 아니면 누가 나한테 물어봐서 응답하고 있는지? = 2

<br/>

- Hardware Address Length
  - 하드웨어 주소의 길이를 나타내는 값.
  - 맥 주소가 6바이트니까, 16진수로 06
- Protocol Address Length
  - 프로토콜 주소의 길이를 나타내는 값.
  - ipv4 주소가 4바이트니까, 16진수로 04.
- Source Hardware Address
  - 송신지 맥 주소
  - 6byte
- Source Protocol Address
  - 송신지 아이피 주소
  - 4byte (IPv4)
- Destination Hardware Address
  - 수신지 맥 주소
  - 6byte
- Destination Protocol Address
  - 수신지 아이피 주소
  - 4byte

<br/>
<br/>

![img-description](assets/img/posting/network/ARP-02.png)
_ARP 프로토콜_

<br/>

1. 송신자는 같은 네트워크 대역의 수신자에게 데이터를 보내고 싶다.
   - IP 주소만 알고 있는 상태이다.
2. ARP 요청을 보낸다.
   - 현재는 IP 주소만을 알고 있다.
   - 따라서 모든 네트워크 대역의 노드들에게 요청을 보낸다.
     - 즉, 이더넷 헤더의 목적지 맥 주소에 전역 주소를 보낸다. (FF:FF:FF:FF:FF:FF)
     - ARP 프로토콜의 목적지 맥 주소는 비워두고 보낸다.
3. 같은 네트워크 대역의 모든 노드가 ARP 요청을 받았다.
   - L2 프로토콜 헤더를 까보고 보인에게 온 것을 확인한다.
   - L3 프로토콜 헤더도 까본다.(ARP)
     - 여기 적힌 IP 주소가 본인이랑 다른걸 확인하고 버려버린다.
     - 맞으면 응답 해준다.
4. 수신자 노드는 본인의 맥 주소를 적어 응답한다.
   - 응답이니 opcode가 2가 된다.
   - 출발지 맥 주소와 출발지 프로토콜 주소에 본인의 주소를 적어준다.
   - 응답을 받을 송신자의 맥 주소와 프로토콜 주소를 도착지 주소에 써서 보낸다.
5. 송신자 노드는 이제 통신을 하고 싶었던 수신자 노드의 맥 주소를 알게 되었다.
   - 송신자 노드는 응답 받은 맥 주소를 잘 기록해둔다.
   - ARP 캐시 테이블에 ip 주소와 대응하는 맥 주소를 잘 적어둔다.


<br/>
<br/>
<br/>
<br/>

# ICMP

- Internet Control Message Protocol
- IP 패킷을 처리할 때 생기는 에러나 필요한 메시지 등을 알리는 프로토콜이다.
  - 상대방과 통신이 안될 때, 얘를 통해 알 수가 있다.
    - 도착지에 가지도 못했어요.
    - 도착은 했는데 응답을 안 보냈어요. 등


<br/>

![img-description](assets/img/posting/network/ICMP.png)
_ICMP 프로토콜_

<br/>

- Type
  - 메시지의 타입이다. 대분류 정도로 생각하면 된다.
  - 여러가지가 있지만 기본적으로 5가지 정도만 알면 된다고 한다.
    - 연결성 검사용
      - 0: Echo Reply(응답), 8: Echo(요청)
    - 재지정
      - 5: Icmp Redirect
        - 원격으로 라우팅 테이블을 수정할 수 있다.
        - 딱 봐도 나쁜 곳에 쓰일 수가 있어서 최근에는 거의 안 쓰인다.
    - 에러 관련
      - 3: Destination unreachable
        - 목적지까지 도달하지 못한 경우
        - 목적지까지 가는 경로의 문제
      - 11: Time exceeded
        - 시간 초과
        - 목적지까지 도달했으나 방화벽 등의 문제로 막힌 경우
        - 혹은 가던 도중에 뺑글뺑글 돌아서 ttl이 끝난 경우 등
- Code
  - 메시지 타입에 대한 코드이다. 소분류 정도로 생각하면 된다.
- Checksum
  - IP에서와 똑같이 얘가 전송되면서 변형이 있었나, 오류가 있었나 등을 확인하는 값.
- Other message specific information
  - 메시지에 필요한 부가 정보가 들어간다.

<br/>
<br/>
<br/>
<br/>
