---
title: 운영체제란
date: 2022-10-07 18:00:00 +0900
categories: [CS, OS]
tags: [cs, os]
---

<br/>
<br/>
<br/>
<br/>

# 운영체제란

<br/>

![img-description](assets/img/posting/os/os-01.png)
_컴퓨터의 구조_

<br/>

- Control program of computer.
- 컴퓨터의 자원(하드웨어)를 제어하여
- 컴퓨터의 성능을 향상 시키고,
- 사용자에게 편의성을 제공하는 프로그램이다.

<br/>

- 운영체제가 하는 일의 범위는 정확히 정의할 수 없다.
  - 예전에 어느 운영체제는 브라우저까지 관여를 해서, 운영체제 사용자들은 그 브라우저만을 사용해야 했다고 한다.
- 운영체제는 사용자가 원하는 실질적인 작업을 수행하지는 않는다.
  - 실제 작업들과 리소스들을 관리하는 역할을 한다.
  - 자원 할당, 자원 관리, 작업 관리 등으로 매우 중요한 역할을 한다.
- 가장 명확하게 알 수 있는 운영체제의 작업은 다음과 같다.
  - 프로세서 관리
  - 메모리 관리
  - 주변 기기 관리 등
  - 얘들을 중점을 배워본다.

<br/>

![img-description](assets/img/posting/os/os-02.png)
_셸과 커널_

<br/>

- 운영체제는 다음과 같이 이뤄져 있다.
- Shell
  - Command interpreter 라고도 한다.
  - 사용자의 명령을 해석해서 커널을 실행하는 역할로 사용자 인터페이스라고 생각하면 된다.
  - 리눅스라면 검은 cmd 창 같은 곳에 ls, cd 이런 명령어를 치는 것으로,
  - 윈도우나 맥이라면 마우스로 아이콘을 클릭하거나 드래그하는 방식으로 컴퓨터에게 명령을 내릴 수 있다.
  - 그런 명령을 받아서 커널에게 전달해 실질적인 동작의 수행을 돕는다.
- Kernel
  - 실제 동작을 수행하는 애다.
  - 위에서 말한 메모리 관리, 프로세서 관리 등을 얘가 수행한다.
  - 앞으로 공부한 내용은 전부 얘가 하는 작업에 관한 것이다.

<br/>
<br/>

# 프로그램 내장식 컴퓨터

<br/>

![img-description](assets/img/posting/os/computer-01.png)
_프로그램 내장식 컴퓨터_

<br/>

- 폰 노이만이 제안한 구조이다.
- 사용하고자 하는 프로그램을 주 메모리에 올려 중앙 처리 장치가 연산을 하는 방식으로 동작한다.
- 사용자가 실행한 프로그램은 서브 메모리에서 주 메모리로 올라간다. 주 메모리에 올라간 프로그램을 프로세서가 한 줄씩 읽어가며, 처리한다.
  - 여기서 서브 메모리에서 주 메모리로 프로그램을 올려주는 것이 운영체제이다.
  - 주 메모리는 빠르고 작지만 휘발성 메모리이고, 서브 메모리는 느리지고 크지만 영구적인 메모리이다.
    - 실행되는 프로그램은 빠른 메모리에 올려 성능적으로 이점을 얻고,
    - 실행중이 아닌 프로그램은 서브 메모리에 넣어둬 용량적인 이점을 얻는다.

<br/>

## 운영체제는 어떻게 메모리에 올라갈까

- 운영체제 역시 하나의 프로그램이다.
- 그 말은 운영체제도 서브 메모리에 저장되어 있고, 실행될 때 주 메모리로 올라가야 한다는 뜻이다.
- 주 메모리의 휘발성이라는 특성상 컴퓨터를 켰을 때는 아무 것도 없는 상태이다.
- 그런데 어떻게 운영체제를 실행할까?

<br/>

![img-description](assets/img/posting/os/computer-02.png)
_컴퓨터가 켜지는 과정_

<br/>

- 메인 메모리는 RAM과 ROM이 있다.
- RAM
  - Random Access Memory
  - 휘발성이다.
    - 전원을 끄면 다 날라간다.
  - 보통 4기가 8기가 16기가 이 정도 사이즈를 사용한다.
  - 일반적으로 주 메모리라고 칭하는 애다.
  - 여기에 프로그램이 올라가고, 얘를 읽어서 프로세서가 프로그램을 처리한다.

- ROM
  - Read Only Memory
  - 비휘발성이다.
  - 얘는 무척 작다. 단위가 수십에서 수백 kb 정도이다.
  - 컴퓨터를 켜면 프로세서는 얘를 읽어서 부팅 프로세스를 진행한다.
  - POST
    - Power On Self Test
    - 컴퓨터 실행시에 프로세서, 메모리, 디스크, 그 외 주변 기기들의 연결 등에 문제가 없는지 테스트한다.
  - Boot Loader
    - Bootstrap Loader라고도 부른다.
    - 커널이 올바르게 시작하기 위한 관련 작업들을 수행하여 운영체제를 실행한다.
    - 서브 메모리에서 운영체제를 찾아 주 메모리에 올리는 작업 등이 있다.

<br/>
<br/>

# 운영체제의 역사(발전 과정)

<br/>

![img-description](assets/img/posting/os/os-03.png)
_초기의 컴퓨터_

<br/>

1. 처음엔 컴퓨터에 운영체제가 없었다.
   - 초기의 컴퓨터는 카드 리더기, 처리기, 메모리, 프린터로 이뤄져 있었다.
     - 카드에 구멍을 적절한 구멍을 내서 프로그램을 짰다고 한다.
     - 그럼 그 카드를 리더기에 읽히면 메모리에 올라가 처리기가 처리했다고 한다.
     - 작업 처리의 결과를 프린터가 종이에 찍어내 볼 수 있었다.
   - 링크, 로딩 등 사람이 모든 업무를 일일이 했다. 이게 너무 귀찮았다.

2. Batch Processing (일괄 처리)
   - 위에서 사람이 항상 귀찮게 하던 일을 일괄적으로 할 수 있는 프로그램이 생겨났다.
     - 컴파일하고, 라이브러리를 링크하고, 메모리에 로딩하는 일들을 순차적으로 묶어 일괄적으로 처리할 수 있었다.
     - 메모리에 상주하며 일괄 처리를 도와주던 최초의 운영체제 격인 프로그램을 resident monitor라고 했다.
   - 그러나 작업의 과정에서 CPU가 노는 시간이 아까웠다.
     - 리더기가 카드를 읽거나, 프린터가 결과를 출력하는 시간 등의
     - I/O 작업을 하는 시간 동안은 CPU는 대기하고 있어야 했다.
     - 게다가 CPU는 I/O 작업에 비해 매우 빨랐기 때문에 이 시간을 줄일 수 있다면, 훨씬 많은 작업을 수행할 수 있었다.

3. Multiprogramming System (다중 프로그래밍)
   - 기존의 한 번에 하나의 프로그램을 수행하던 방식과 다르게
   - 메모리에 여러 개의 프로그램을 올려두고 작업을 수행하는 방식이다.
     - 1번 프로그램을 처리하던 CPU가 I/O 작업이 발생되어서,
     - 1번 프로그램이 I/O 작업을 수행하는 동안 2번 프로그램을 처리한다.
     - 2번 프로그램이 I/O 작업이 발생하면, 또 3번 프로그램을 처리한다.
   - 비싼 CPU의 idle time으로 인한 낭비를 줄일 수 있게 된 것이다.
   - 여기서는 단순히 1번 -> 2번 -> 3번이라고 대충 나타냈지만, 다음 CPU를 어떤 프로그램이 받을 지를 결정하는 것도 성능에 큰 영향을 끼친다.
     - 이것을 CPU 스케쥴링이라고 한다.
   - 또 메모리에 여러개의 프로그램이 올라가기 때문에
     - 어떤 프로그램을 메모리의 어느곳에 올릴지를 고려해야 한다.
     - 메모리에 다른 프로그램들이 동시에 작업을 수행하는 상황에서, 서로의 진행 상황 등에 영향을 주지 않아야 한다.

<br/>

![img-description](assets/img/posting/os/os-04.png)
_시분할 시스템_

<br/>

4. Time-Sharing System (시분할 시스템)
   - 시분할 시스템이란, 여러 프로세스를 조금씩 조금씩 빠르게 돌아가면서 처리하는 방식이다.
     - 여러 프로세스를 짧은 속도로 빠르게 왔다갔다 한다.
     - 처리 속도가 매우 빠르기 때문에 각각의 프로세스들이 동시에 처리되는 것처럼 보인다.
   - 시분할 시스템은 컴퓨터를 대화식으로 사용하려는 시도에서 탄생하였다.
     - 대화식 컴퓨터란 Terminal 등의 I/O 장치가 발달하고 (터미널이란, 키보드와 모니터가 달린 통신 장비)
     - 그 I/O 장치들로 사용자의 키보드 입력에 컴퓨터가 모니터로 바로 결과를 출력하는 방식이다.
   - 예전의 컴퓨터는 너무 비쌌기 때문에 컴퓨터 한 대를 여러 명의 사용자가 같이 사용하였다.
     - 하나의 컴퓨터에 여러 대의 키보드-모니터 쌍을 설치하고 여러 명이 사용하였다.
     - 예시를 들어보면, 기존에는 이런 방식이었다.
       - 유저1, 유저2, 유저3이 있다.
       - 이들은 각각 프로그램1, 프로그램2, 프로그램3을 사용한다.
       - 만약 유저1의 프로그램1을 CPU가 처리중이라면,
       - 유저2와 유저3은 그저 기다려야 한다.
     - 시분할 시스템 이후에는,
       - 유저1의 프로그램1과 유저2의 프로그램2와 유저3의 프로그램3을
       - CPU가 짧은 간격으로 돌아가면서 처리한다.
       - 처리 속도가 매우 빠르기 때문에 유저들은 전부 자신의 프로그램이 계속 처리되고 있는 것처럼 느낀다.
   - 시분할 시스템으로 인해서
     - 프로세스 간 통신이 가능해졌다.
       - 여러 프로세스가 동시에 실행할 수 있게 되었기 때문에.
     - 프로세스 간의 동기화를 고려해야 된다.
       - 여러 프로세스가 동시에 실행되기 때문에.
     - 메모리에 여러 프로그램이 올라가게 되면서 메모리가 부족해졌다.
       - 서브 메모리를 주 메모리가 빌려 사용하는 가상 메모리 기술이 생겨났다.

5. Interrupt-Based System

- 현대의 운영체제들은 대부분 인터럽트 기반 시스템을 갖추고 있다.
- 인터럽트란 우리말로 하면 가로채기로 해석할 수 있는데,
  - 운영체제가 인터럽트 신호를 받으면, 하던 일을 멈추고 신호에 맞는 행동을 한다. ISR(Interrupt Service Routine)
  - 정해진 ISR을 다하면 다시 원래 프로세스를 진행한다.
- 인터럽트는 두 가지로 나눌 수 있다.
  - 하드웨어 인터럽트
    - 우리가 마우스를 움직이면 즉각적으로 움직이는 것을 볼 수 있다.
    - 우리가 타이핑을 치면 즉각적으로 입력되는 것을 볼 수 있다.
  - 소프트웨어 인터럽트
    - 유저 프로그램을 사용중에 오류나 이벤트를 알리기 위해 발생하는 인터럽트이다.
    - Exception(예외)라고도 한다.

<br/>
<br/>
<br/>
<br/>
