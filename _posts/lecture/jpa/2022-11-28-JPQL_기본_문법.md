---
title: JPQL 기본 문법
date: 2022-11-29 11:00:00 +0900
categories: [자바 ORM 표준 JPA, JPQL_기본_문법]
isLecture: true
---

<br/>
<br/>
<br/>
<br/>

### 참고

- [자바 ORM 표준 JPA 프로그래밍 - 김영한](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)
- [JPA Query Parameters Usage - Baeldung](https://translate.google.com/?sl=en&tl=ko&text=Embedding%20parameters%20introduce%20a%20security%20risk%2C%20making%20us%20vulnerable%20to%20JPQL%20injection%20attacks.%20Instead%20of%20the%20expected%20value%2C%20an%20attacker%20may%20inject%20any%20unexpected%20and%20possibly%20dangerous%20JPQL%20expression.%0A%0ADepending%20on%20the%20JPA%20implementation%20we%20use%2C%20and%20the%20heuristics%20of%20our%20application%2C%20the%20query%20cache%20may%20get%20exhausted.%20A%20new%20query%20may%20get%20built%2C%20compiled%2C%20and%20cached%20each%20time%20we%20use%20it%20with%20each%20new%20value%2Fparameter.%20At%20a%20minimum%2C%20it%20won%27t%20be%20efficient%2C%20and%20it%20may%20also%20lead%20to%20an%20unexpected%20OutOfMemoryError.&op=translate)

<br/>
<br/>


# JPQL

- 원래 JPA에서 엔티티의 변경이 일어난 경우에 (엔티티가 영속 상태라면) 커밋 시점에 자동으로 변경에 대한 쿼리가 날아간다.
  - 그러나 이 경우에는 변경이 일어난 엔티티마다 쿼리가 하나씩 날아간다.
  - 또 조회 역시 em.find()를 통해 엔티티를 받아오면 엔티티 하나당 하나의 쿼리가 날아간다.
- JPQL은 벌크 연산(대량의 데이터를 한 번에 불러오는 연산)이 가능하다.

<br/>
<br/>
<br/>
<br/>

# JPQL 기본 문법

- 엔티티와 멤버 변수의 대소문자를 구별해야 한다.
- JPQL 키워드의 경우엔 대소문자를 구별하지 않는다.
- 테이블의 이름이 아닌 엔티티의 이름을 사용한다.
- 엔티티의 별칭이 필수이다.

<br/>

## SELECT

```java

List<Book> resultList = em.createQuery("SELECT b FROM Book b WHERE b.title LIKE :title", Book.class)
        .setParameter("title", "book%");
        .getResultList();

```

- title이 book으로 시작하는 Book 엔티티를 리스트로 받아온 것을 볼 수 있다.

<br/>

## UPDATE

```java

int i = em.createQuery("UPDATE Book b SET b.title = :newTitle WHERE b.title = :title")
        .setParameter("newTitle", "babo")
        .setParameter("title", "book1")
        .executeUpdate();

```

- title이 book1인 Book 엔티티의 title을 babo로 업데이트한 것을 볼 수 있다.
- 정수형 리턴값은 update 문에 영향을 받은 로우의 수를 반환해준 것이다.
  - title이 book1인 Book 엔티티가 한 개 뿐이라면 1이 반환될 것이고
  - title이 book1인 Book 엔티티가 여러개라면 그 개수가 반환된다.

<br/>

## DELETE

```java

int i = em.createQuery("DELETE FROM Book b WHERE b.title = :title")
        .setParameter("title", "book1");
        .executeUpdate();

```

- title이 book1인 Book 엔티티를 모두 삭제한 것이다.
- 반환된 정수값은 역시 삭제된 로우의 개수이다.

<br/>
<br/>

# 집합과 정렬

- Aggregate function
  - count, avg, sum, max, min
- group by, having
- order by
- 모두 사용 가능하다.

<br/>

## 집계 함수


### count

```java

Long count = em.createQuery("SELECT COUNT(b) FROM Book b", Long.class)
        .getSingleResult();

```

- count 함수 사용법이다.
- getSingleResult()를 사용해서 결과를 받아온다.
- 반환 타입은 Long으로 잡아줘야 한다.

<br/>

### sum

```java

Long sum = em.createQuery("SELECT SUM(b.price) FROM Book b", Long.class)
        .getSingleResult();

```

<br/>

### avg

```java

Long avg = em.createQuery("SELECT AVG(b.price) FROM Book b", Long.class)
        .getSingleResult();

```

<br/>

### min

```java

Long min = em.createQuery("SELECT MIN(b.price) FROM Book b", Long.class)
        .getSingleResult();

```

<br/>

### max

```java

Long max = em.createQuery("SELECT MAX(b.price) FROM Book b", Long.class)
        .getSingleResult();

```

<br/>
<br/>

## 그룹과 정렬

### group by

```java

Long count = em.createQuery("SELECT COUNT(b) FROM Book b GROUP BY b.bookshelf HAVING COUNT(b) > 1", Long.class)
    .getSingleResult();

```

<br/>

### order by

```java

Long count = em.createQuery("SELECT COUNT(b) as cnt FROM Book b GROUP BY b.bookshelf HAVING COUNT(b) > 1 ORDER BY cnt ASC", Long.class)
    .getSingleResult();

```

- 여기서 좀 특이한게 order by 에는 as로 지정한 별칭이 사용 가능한다.
  - having에 별칭을 넣으면 에러가 뜬다.


<br/>
<br/>
<br/>
<br/>

# JPQL 반환 타입

- EntityManager의 createQuery()는 두 가지의 리턴 타입이 있다.
  - Query
    - 반환 타입이 명확하지 않은 경우에 잡힌다.
  - TypedQuery
    - 반환 타입이 명확한 경우
    - createQuery()의 두 번째 인자로 타입을 넘겨준 경우에 그 타입으로 반환 타입이 잡힌다.

<br/>

```java

// 반환 타입을 넘겨준 경우
TypedQuery typedQuery = em.createQuery("SELECT b FROM Book b", Book.class);

// 반환 타입이 명확하지 않아 인자로 넘겨주지 않은 경우
Query query = em.createQuery("SELECT b.title, b.price FROM Book b");

```

<br/>
<br/>
<br/>
<br/>

# 결과 조회

- Query 또는 TypedQuery 타입을 실행 시켜 결과를 받아와야 한다.
- 결과 조회 api에는 자주 쓰이는 두 가지가 있다.
  - getSingleResult();
    - 하나의 결과값을 받음.
    - 쿼리의 결과가 정확히 하나여야 한다. 아니면 예외가 발생한다.
      - 결과가 없으면, javax.persistence.NoResultException
      - 결과가 2개 이상이면, javax.persistence.NonUniqueResultException
  - getResultList();
    - 결과를 리스트로 받는다.
    - 결과가 없으면 빈 리스트로 준다.


<br/>
<br/>
<br/>
<br/>

# 파라미터 바인딩

- JPQL을 사용한 쿼리 객체는 setParameter() 메서드를 사용해서 파라미터 바인딩을 해줄 수 있다.
- 파라미터 바인딩은 두 가지 방식이 있다.
  - 이름 기준
  - 위치 기준

<br/>

```java

// 이름 기준
em.createQuery("SELECT b FROM Book b WHERE b.title = :title")
    .setParameter("title", "babo book");

// 위치 기준
em.createQuery("SELECT b FROM Book b WHERE b.title = ?1")
    .setParameter(1, "babo book")

```

<br/>

- 사용법은 위와 같다.
- 위치 기준은 권장되지 않는다.
  - 파라미터가 늘어나서 순서가 꼬이면 숫자를 바꿔준다거나 하는 일이 생기니까-

<br/>
<br/>

## 파라미터 바인딩 꼭 써야 하나요

- 그냥 JPQL 스트링에 값을 직접 넣어도 잘 동작한다.
- 그런데 왜 성가시게 저걸 써야할까
- 크게 두 가지 이유가 있다.
  - 보안에 취약점이 생긴다.
    - [SQL Injection](/posts/SQL_Injection/)
  - 메모리 낭비가 생긴다.
    - [Hibernate Query Plan Cache](/posts/Query_Plan_Cache)


<br/>
<br/>
<br/>
<br/>

# 프로젝션

- select 절에서 조회할 대상을 지정하는 것을 말한다.
- 프로젝션의 대상은 다음과 같다.
  - 엔티티 프로젝션
  - 임베디드 타입 프로젝션
  - 스칼라 타입 프로젝

<br/>
<br/>

## 엔티티 프로젝션

```java

List<Bookshelf> resultList = em.createQuery("SELECT bs FROM Bookshelf bs", Bookshelf.class)
    .getResultList();

```

- 기본적인 엔티티 조회 쿼리이다.
- 결과로 엔티티의 리스트를 받아온다.

<br/>

```java

List<Book> resultList = em.createQuery("SELECT bs.bookList FROM Bookshelf bs", Book.class)
    .getResultList();

```

- 연관 관계 엔티티를 조회하는 쿼리이다.
- 결과로 연관 관계 엔티티의 리스트를 받아온다.

<br/>
<br/>

## 임베디드 타입 프로젝션

```java

List<RentalPeriod> resultList = em.createQuery("SELECT b.rentalReriod FROM Book b", RentalPeriod.class)
    .getResultList();

```

- 엔티티의 임베디드 값 타입을 조회하는 쿼리이다.
- 임베디드 값 타입으로 결과를 받아온다.

<br/>
<br/>

# 스칼라 타입 프로젝션

```java

List<String> resultList = em.createQuery("SELECT b.title FROM Book b", String.class)
    .getResultList();

```

- 하나의 기본 값 타입을 조회하는 쿼리이다.
- 조회 컬럼이 하나라면 기본 값 타입으로 결과로 받아볼 수 있다.


## Object로 조회

```java

List resultList = em.createQuery("SELECT b.title, b.price FROM Book b")
    .getResultList();

for(Object result : resultList) {
    Object[] o = (Object[]) result;

    souf("title= %s, price= %d \n", o[0], o[1]);
}

```

- 2개 이상의 기본 값 타입을 조회하는 쿼리이다.
- 여기서는 createQuery()의 리턴값을 Query로 받는다.
  - 결과 역시 raw 타입 리스트로 받는다.

<br/>


## Object[]로 조회

```java

List<Object[]> resultList = em.createQuery("SELECT b.title, b.price FROM Book b", Object[].class)
    .getResultList();

    for(Object[] o : resultList) {
        souf("title= %s, price= %d \n", o[0], o[1]);
    }

```

- 이렇게 TypedQuery를 사용하는 방법도 있다.

<br/>


## DTO로 조회

```java

@Getter
@AllArgsConstructor
class BookInfoDto {
    private String title;
    private int price;
}

```
```java

List<BookInfoDto> resultList = em.createQuery("SELECT new me.bogeun.dto.BookInfoDto(b.title, b.price) FROM Book b", BookInfoDto.class)
    .getResultList();

```

- 위에 처럼 조회할 컬럼의 타입에 맞는 DTO를 만들어 조회하는 방법이다.
- JPQL에는 new 연산자를 사용한다.
  - DTO 클래스의 FQCN을 적어줘야 한다.
  - DTO 클래스에는 적합한 생성자 함수가 정의돼야 한다.

<br/>
<br/>
<br/>
<br/>
